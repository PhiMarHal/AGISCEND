<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@0.3.0/dist/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.87.0/dist/phaser.min.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000000;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        canvas {
            outline: none;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <script>
        // Wait for CDN dependencies to load
        (async function () {
            const expectedGlobals = ["FarcadeSDK", "Phaser"];
            console.log('[Run Game] Waiting for CDN dependencies:', expectedGlobals);

            // Wait for expected global objects from CDN scripts
            const maxWaitTime = 10000;
            const checkInterval = 50;
            let elapsed = 0;
            let lastLogTime = 0;

            while (!(window.FarcadeSDK && window.Phaser) && elapsed < maxWaitTime) {
                if (elapsed - lastLogTime >= 1000) {
                    const available = [window.FarcadeSDK ? 'FarcadeSDK' : null, window.Phaser ? 'Phaser' : null].filter(Boolean);
                    console.log(`[Run Game] Waiting... (${elapsed}ms) Available:`, available);
                    lastLogTime = elapsed;
                }

                await new Promise(resolve => setTimeout(resolve, checkInterval));
                elapsed += checkInterval;
            }

            if (!(window.FarcadeSDK && window.Phaser)) {
                console.error('[Run Game] CDN dependencies not loaded in time. Expected:', expectedGlobals);
                return;
            }

            console.log('[Run Game] All dependencies loaded!');
            console.log('[Run Game] Phaser:', typeof window.Phaser, window.Phaser?.VERSION);
            console.log('[Run Game] FarcadeSDK:', typeof window.FarcadeSDK, Object.keys(window.FarcadeSDK || {}));

            // Additional wait for SDK mock to be fully ready
            if (window.FarcadeSDK) {
                let sdkReadyCount = 0;
                while (!window.FarcadeSDK.singlePlayer && sdkReadyCount < 100) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    sdkReadyCount++;
                }
                if (window.FarcadeSDK.singlePlayer) {
                    console.log('[Run Game] FarcadeSDK.singlePlayer ready');
                }
            }

            console.log('[Run Game] Starting game execution...');

            // Embed source map
            window.__REMIX_SOURCE_MAP__ = { "main.js": { "file": "main.js", "offset": 0 } };

            window.addEventListener('unhandledrejection', (event) => {
                console.error('[Run Game] Unhandled promise rejection:', event.reason);
            });

            // Execute game code
            try {

                // === FILE: main.js ===

                // NO Phaser.js import — Phaser is loaded via CDN and available on the window object

                /**
                 * Music Configuration
                 */
                const BASE_URL = 'https://agiscend.loiyaa.com/';
                const isLocal = window.location.protocol === 'file:';
                const TRACK_COUNT = 9;
                const SILENCE_BETWEEN_TRACKS = 4000; // 4 seconds

                // Music state
                let musicPlaylist = [];
                let currentTrackIndex = 0;
                let audioElement = null;
                let musicStarted = false;
                let isTransitioning = false;
                let isMusicMuted = false; // Track mute state globally

                // Shuffle array (Fisher-Yates)
                function shuffleArray(array) {
                    const arr = [...array];
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    return arr;
                }

                // Generate shuffled playlist
                function generatePlaylist() {
                    const tracks = [];
                    for (let i = 1; i <= TRACK_COUNT; i++) {
                        const trackNum = i.toString().padStart(2, '0');
                        const trackPath = isLocal
                            ? `assets/track_${trackNum}.mp3`
                            : `${BASE_URL}assets/track_${trackNum}.mp3`;
                        tracks.push(trackPath);
                    }
                    return shuffleArray(tracks);
                }

                // Play next track
                function playNextTrack() {
                    if (!musicStarted || isTransitioning) return;
                    isTransitioning = true;

                    // If we've played all tracks, reshuffle
                    if (currentTrackIndex >= musicPlaylist.length) {
                        musicPlaylist = generatePlaylist();
                        currentTrackIndex = 0;
                    }

                    const trackPath = musicPlaylist[currentTrackIndex];
                    currentTrackIndex++;

                    // Clean up old audio element completely
                    if (audioElement) {
                        audioElement.pause();
                        audioElement.removeAttribute('src');
                        audioElement.load();
                        audioElement = null;
                    }

                    // Create fresh audio element
                    audioElement = new Audio();
                    audioElement.volume = 0.5;
                    audioElement.muted = isMusicMuted; // Respect mute setting

                    // Set up event handlers BEFORE setting src
                    audioElement.onended = () => {
                        isTransitioning = false;
                        // Wait for silence period, then play next
                        setTimeout(playNextTrack, SILENCE_BETWEEN_TRACKS);
                    };

                    audioElement.onerror = () => {
                        console.warn('Could not load track:', trackPath);
                        isTransitioning = false;
                        // Try next track after a short delay
                        setTimeout(playNextTrack, 1000);
                    };

                    audioElement.oncanplaythrough = () => {
                        isTransitioning = false;
                        // Only play if not muted
                        if (!isMusicMuted) {
                            audioElement.play().catch(e => {
                                console.warn('Playback failed:', e);
                            });
                        }
                    };

                    // Now set the source
                    audioElement.src = trackPath;
                    audioElement.load();
                }

                // Start music (call after user interaction)
                function startMusic() {
                    if (musicStarted) return;
                    musicStarted = true;
                    isTransitioning = false;
                    musicPlaylist = generatePlaylist();
                    currentTrackIndex = 0;
                    playNextTrack();
                }

                // Pause/resume music on tab visibility change
                document.addEventListener('visibilitychange', () => {
                    if (!audioElement) return;
                    if (document.hidden) {
                        audioElement.pause();
                    } else {
                        if (musicStarted) {
                            audioElement.play().catch(() => { });
                        }
                    }
                });

                /**
                 * Game Settings
                 * Centralized configuration for all tunable game parameters
                 */
                const GameSettings = {
                    canvas: {
                        width: 720,
                        height: 1080,
                    },
                    colors: {
                        background: "#ffffff",
                        primary: "#000000",
                        secondary: "#ffffff", // Eye whites
                        hazard: "#000000"
                    },
                    gameplay: {
                        gravity: 1600,
                        jumpForce: 650,
                        horizontalSpeed: 400,
                        baseHazardSpeed: 100, // Base spike speed
                        hazardSpeed: 100, // Current spike speed
                        obstacleSize: 45,
                        wallThickness: 35,
                        coinSpawnRate: 0.8,
                        checkpointInterval: 2000,
                        minDistance: 160
                    },
                    intervals: {
                        baseInterval: 10000, // 10000m base interval
                    },
                    // Obstacle types with interval-based spawning
                    // startInterval: which interval this obstacle begins spawning (1 = from start)
                    // spawnRate: [min, max] per interval
                    obstacleTypes: {
                        pentagon: {
                            startInterval: 5, // Set to 1 for testing, change to 5 for production
                            spawnRate: [4, 8], // Bumped slightly for more reliable 2-8 range
                            size: 240, // ~2.7x block size
                            moveSpeed: 80, // Downward movement speed
                            rotationRange: 60, // Degrees to rotate back and forth
                            rotationSpeed: 0.001 // Rotation oscillation speed
                        },
                        hexagon: {
                            startInterval: 9, // Set to 1 for testing
                            spawnRate: [4, 8], // Pairs per interval
                            size: 100, //
                            fireDuration: 2000, // 1 second firing
                            rechargeDuration: 1000, // 1 second recharge
                            spinDuration: 500 // Last 0.5 second of recharge = spinning
                        }
                    },
                    visuals: {
                        heroBaseScale: 1.2
                    },
                    _meta: {
                        "colors.background": { type: "color", label: "Background Color" },
                        "colors.primary": { type: "color", label: "Main Object Color" },
                        "colors.hazard": { type: "color", label: "Spike Color" },
                        "gameplay.gravity": { type: "number", label: "Gravity", min: 500, max: 3000 },
                        "gameplay.jumpForce": { type: "number", label: "Flap Power", min: 200, max: 1000 },
                        "gameplay.horizontalSpeed": { type: "number", label: "Move Speed", min: 100, max: 800 },
                        "gameplay.baseHazardSpeed": { type: "number", label: "Rising Speed", min: 10, max: 400 },
                        "gameplay.minDistance": { type: "number", label: "Min Block Spacing", min: 100, max: 300 }
                    }
                }

                /**
                 * Config Manager
                 * Handles runtime configuration updates from the editor via postMessage.
                 */
                const ConfigManager = {
                    gameInstance: null,
                    gameScene: null,
                    metadata: GameSettings._meta || {},

                    init(gameInstance, gameScene) {
                        this.gameInstance = gameInstance
                        this.gameScene = gameScene
                        this.loadFromStaticConfig()
                        window.addEventListener('message', (event) => {
                            this.handleMessage(event)
                        })
                        console.log('[ConfigManager] Initialized')
                    },

                    loadFromStaticConfig() {
                        try {
                            const configScript = document.getElementById('game-config')
                            if (configScript && configScript.textContent) {
                                const staticConfig = JSON.parse(configScript.textContent)
                                this.applyConfig(staticConfig, false)
                            }
                        } catch (error) {
                            console.warn('[ConfigManager] Failed to load static config:', error)
                        }
                    },

                    handleMessage(event) {
                        const isFromParent = event.source === window.parent
                        const isFromSameWindow = event.source === window
                        const isWebViewContext = typeof window.ReactNativeWebView !== 'undefined'

                        if (isWebViewContext) {
                            if (!isFromSameWindow && event.origin !== 'react-native://webview') {
                                return
                            }
                        } else {
                            if (!isFromParent) {
                                return
                            }
                        }

                        if (!event.data || typeof event.data !== 'object') {
                            return
                        }

                        const { type, path, value, config } = event.data

                        switch (type) {
                            case 'GET_CONFIG_SCHEMA':
                                this.sendSchema()
                                break
                            case 'GET_CONFIG_VALUES':
                                this.sendValues()
                                break
                            case 'UPDATE_CONFIG_PROPERTY':
                                if (path && value !== undefined) {
                                    this.updateProperty(path, value)
                                }
                                break
                            case 'UPDATE_CONFIG':
                                if (config) {
                                    this.applyConfig(config, true)
                                }
                                break
                        }
                    },

                    getConfigurableProperties() {
                        const properties = {}
                        const meta = this.metadata

                        const scan = (obj, prefix = '') => {
                            for (const [key, val] of Object.entries(obj)) {
                                if (key === '_meta') continue
                                const path = prefix ? `${prefix}.${key}` : key
                                if (typeof val === 'object' && val !== null && !Array.isArray(val)) {
                                    scan(val, path)
                                } else {
                                    const valueType = this.detectType(val)
                                    properties[path] = {
                                        type: meta[path]?.type || valueType,
                                        label: meta[path]?.label || this.formatLabel(key),
                                        default: val,
                                        ...(meta[path] || {}),
                                    }
                                }
                            }
                        }

                        scan(GameSettings)
                        return properties
                    },

                    detectType(value) {
                        if (typeof value === 'string' && /^#[0-9A-Fa-f]{6}$/.test(value)) {
                            return 'color'
                        }
                        if (typeof value === 'number') {
                            return 'number'
                        }
                        if (typeof value === 'boolean') {
                            return 'boolean'
                        }
                        return 'string'
                    },

                    formatLabel(key) {
                        return key
                            .split(/(?=[A-Z])/)
                            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ')
                    },

                    getCurrentValues() {
                        const values = {}
                        const properties = this.getConfigurableProperties()
                        for (const path of Object.keys(properties)) {
                            values[path] = this.getPropertyValue(path)
                        }
                        return values
                    },

                    getPropertyValue(path) {
                        const parts = path.split('.')
                        let value = GameSettings
                        for (const part of parts) {
                            if (value && typeof value === 'object') {
                                value = value[part]
                            } else {
                                return undefined
                            }
                        }
                        return value
                    },

                    updateProperty(path, value) {
                        const parts = path.split('.')
                        let current = GameSettings
                        for (let i = 0; i < parts.length - 1; i++) {
                            if (!current[parts[i]]) {
                                current[parts[i]] = {}
                            }
                            current = current[parts[i]]
                        }
                        const key = parts[parts.length - 1]
                        const oldValue = current[key]
                        current[key] = value
                        this.applyPropertyChange(path, value, oldValue)
                        this.notifyPropertyUpdated(path, value)
                    },

                    applyPropertyChange(path, value, oldValue) {
                        if (!this.gameScene) return
                        if (typeof this.gameScene.onConfigUpdate === 'function') {
                            this.gameScene.onConfigUpdate(path, value, oldValue)
                        }
                        if (path.startsWith('colors.')) {
                            if (typeof this.gameScene.updateColor === 'function') {
                                const colorName = path.split('.')[1]
                                this.gameScene.updateColor(colorName, value)
                            }
                        }
                    },

                    applyConfig(config, notifyParent = true) {
                        for (const [key, value] of Object.entries(config)) {
                            if (key === '_meta') continue
                            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                                if (!GameSettings[key]) {
                                    GameSettings[key] = {}
                                }
                                Object.assign(GameSettings[key], value)
                            } else {
                                GameSettings[key] = value
                            }
                        }
                        const properties = this.getConfigurableProperties()
                        for (const path of Object.keys(properties)) {
                            const value = this.getPropertyValue(path)
                            this.applyPropertyChange(path, value, undefined)
                        }
                        if (notifyParent) {
                            this.sendValues()
                        }
                    },

                    sendSchema() {
                        const schema = this.getConfigurableProperties()
                        window.parent.postMessage({ type: 'CONFIG_SCHEMA', schema }, '*')
                    },

                    sendValues() {
                        const values = this.getCurrentValues()
                        window.parent.postMessage({ type: 'CONFIG_VALUES', values }, '*')
                    },

                    notifyPropertyUpdated(path, value) {
                        window.parent.postMessage({ type: 'CONFIG_PROPERTY_UPDATED', path, value }, '*')
                    },
                }

                /**
                 * GameScene - Main game scene
                 */
                class GameScene extends Phaser.Scene {
                    constructor() {
                        super({ key: 'GameScene' })
                        this.resetGameState()
                    }

                    resetGameState() {
                        this.score = 0
                        this.isGameOver = false
                        this.hasStarted = false
                        this.highestGeneratedY = 0
                        this.lastObstacleY = 0
                        this.nextFlapDirection = 1
                        this.lastFlapTime = 0
                        this.flapCooldown = 200
                        this.lastCheckpointReached = 0
                        this.restartTime = Date.now() // Track when game restarted to prevent immediate input

                        // Interval system state (Consistent 10k steps)
                        this.intervalAltitudes = []
                        for (let n = 1; n <= 100; n++) {
                            this.intervalAltitudes.push(n * 10000)
                        }

                        this.lastIntervalAltitude = 0 // For spawn rate reset calculation
                        this.nextIntervalIndex = 0 // Index into intervalAltitudes
                        this.generatedIntervalBarriers = new Set() // Track which interval barriers have been generated

                        // Hexagon pairs tracking
                        this.hexagonPairs = []

                        // Beam hit stun - prevents flapping after beam hit
                        this.beamHitTime = 0

                        // Spike Warning UI state (distance-based)
                        this.spikeWarningLevel = 0  // 0 = safe, 1 = caution (< 2000m), 2 = danger (< 1000m)
                    }

                    create() {
                        this.generateTextures()
                        this.resetGameState()

                        // Reset spike speed to base on game start/restart
                        GameSettings.gameplay.hazardSpeed = GameSettings.gameplay.baseHazardSpeed

                        // 1. Setup World
                        this.cameras.main.setBackgroundColor(GameSettings.colors.background)
                        this.physics.world.gravity.y = GameSettings.gameplay.gravity

                        // 2. Parallax Background System (TileSprites)
                        // Texture is 1024px wide (512*2), so TileSprite should match
                        // Scale to fit canvas: 720/1024
                        const bgScale = GameSettings.canvas.width / 1024

                        // Far Layer: lighter gray background
                        this.bgFar = this.add.tileSprite(GameSettings.canvas.width / 2, 0, 1024, 2048, 'bg_far')
                            .setOrigin(0.5, 0)
                            .setScrollFactor(0)
                            .setDepth(-10)
                            .setScale(bgScale)

                        // Mid Layer: darker gray foreground
                        this.bgMid = this.add.tileSprite(GameSettings.canvas.width / 2, 0, 1024, 2048, 'bg_mid')
                            .setOrigin(0.5, 0)
                            .setScrollFactor(0)
                            .setDepth(-9)
                            .setScale(bgScale)

                        // 3. Create Groups
                        this.walls = this.physics.add.staticGroup()
                        this.obstacles = this.physics.add.staticGroup()
                        this.coins = this.physics.add.group({
                            allowGravity: false,
                            immovable: true
                        })
                        // Pentagons: dynamic group (they move), but immovable (player bounces off)
                        this.pentagons = this.physics.add.group({
                            allowGravity: false,
                            immovable: true
                        })
                        // Hexagons: static group (wall-mounted)
                        this.hexagons = this.physics.add.staticGroup()
                        // Hexagon beams: static group for the laser rays
                        this.hexagonBeams = this.physics.add.staticGroup()

                        // Spikes Container for undulation
                        this.spikeContainer = this.add.container(0, GameSettings.canvas.height + 50)

                        // Add background rectangle to the container to mask individual spikes
                        // It should start at a lower position (e.g. y=30) so the top of the spikes is visible.
                        const spikeBgHeight = 2000
                        const spikeBg = this.add.rectangle(0, 45, GameSettings.canvas.width, spikeBgHeight, 0x000000)
                        spikeBg.setOrigin(0, 0) // Positioned at y=45 within container

                        // Surge smoothing logic helper
                        this.surgeTargetY = this.spikeContainer.y

                        this.spikes = []
                        const spikeCount = 16 // Increased count for better visual density
                        const totalSpikeSpace = GameSettings.canvas.width
                        const spikeWidth = totalSpikeSpace / (spikeCount + 1)

                        // Add the black base first so it sits behind the undulation
                        this.spikeContainer.add(spikeBg)

                        for (let i = 0; i < spikeCount; i++) {
                            // Positioned at y=0, with the base extending down to y=64
                            const s = this.add.image((i + 1) * spikeWidth, 0, 'spike_single').setOrigin(0.5, 0)
                            this.spikeContainer.add(s)
                            this.spikes.push(s)
                        }

                        this.physics.add.existing(this.spikeContainer)
                        this.spikeContainer.body.setAllowGravity(false)
                        this.spikeContainer.body.setImmovable(true)
                        // Physics body starts at the tip of the spikes (y=0 in container)
                        this.spikeContainer.body.setSize(GameSettings.canvas.width, 100)
                        this.spikeContainer.body.setOffset(0, 0)

                        // 4. Create Player
                        const startY = GameSettings.canvas.height - 200

                        // Safety boundaries: Physical world locking
                        const wallThick = GameSettings.gameplay.wallThickness
                        // We set the world bounds to the space BETWEEN the walls.
                        // Width = Canvas Width minus both walls. X offset = thickness of one wall.
                        this.physics.world.setBounds(wallThick, -2000000, GameSettings.canvas.width - (wallThick * 2), 2000000 + GameSettings.canvas.height)

                        // Create the physics sprite as the primary player object
                        this.player = this.physics.add.sprite(GameSettings.canvas.width / 2, startY, 'player')
                        // Using Rectangular body for improved collision stability with static blocks
                        this.player.setSize(26, 26)
                        this.player.setOffset(17, 17)

                        // Scale reset: Starting at 1.2 "normal" scaling - set both axes explicitly
                        this.player.setScale(1.2, 1.2)
                        this.player.setBounce(2.0)
                        this.player.setCollideWorldBounds(true)
                        this.player.setMaxVelocity(GameSettings.gameplay.horizontalSpeed * 2, 2400)

                        // Ensure the player is strictly locked between the inner edges using world bounds
                        this.player.body.setCollideWorldBounds(true)

                        this.player.setDepth(10)

                        // Eye Design: Elongated ovals with clear black outlines
                        const eyeWidth = 42; // ~10% larger than previous 38.5
                        const eyeHeight = 29; // ~10% larger than previous 26.4
                        const outlineColor = 0x000000;
                        const outlineThickness = 3;

                        // Create Left Eye with Outline
                        this.eyeLeft = this.add.ellipse(-24, -4, eyeWidth, eyeHeight, Phaser.Display.Color.HexStringToColor(GameSettings.colors.secondary).color)
                        this.eyeLeft.setStrokeStyle(outlineThickness, outlineColor)

                        // Create Right Eye with Outline
                        this.eyeRight = this.add.ellipse(24, -4, eyeWidth, eyeHeight, Phaser.Display.Color.HexStringToColor(GameSettings.colors.secondary).color)
                        this.eyeRight.setStrokeStyle(outlineThickness, outlineColor)

                        // Cat Pupils: Vertical slit (black part)
                        this.pupilLeft = this.add.rectangle(0, 0, 6.6, 19.8, Phaser.Display.Color.HexStringToColor(GameSettings.colors.primary).color)
                        this.pupilRight = this.add.rectangle(0, 0, 6.6, 19.8, Phaser.Display.Color.HexStringToColor(GameSettings.colors.primary).color)

                        // Add both whites and pupils to container - positioned at player center
                        this.playerEyes = this.add.container(0, 0, [
                            this.eyeLeft, this.eyeRight, this.pupilLeft, this.pupilRight
                        ])

                        this.playerEyes.setDepth(11)

                        // Sync eye container position with player in postUpdate (after physics) for perfect sync
                        this.events.on('postupdate', () => {
                            if (this.player && this.playerEyes && !this.isGameOver) {
                                this.playerEyes.x = this.player.x
                                this.playerEyes.y = this.player.y
                            }
                        })

                        // Internal eye states for smooth movement
                        this.targetEyePos = { x: 0, y: 0 }
                        this.currentEyePos = { x: 0, y: 0 }
                        this.targetPupilPos = { x: 0, y: 0 }
                        this.currentPupilPos = { x: 0, y: 0 }

                        // Helper for physics body sync after scaling
                        // IMPORTANT: We use a fixed body size that represents the core of the player
                        // to prevent getting stuck during scaling physics updates. 
                        this.player.on('scale_update', () => {
                            if (this.player.body) {
                                // Sync but keep the collision body constant relative to the base 1.2 scale
                                // to avoid "growing" into walls during Tweens.
                                const baseRadius = 16;
                                const currentScale = this.player.scaleY;
                                // Instead of scaling the body, we keep the hitsphere stable
                                // or scale it slightly less to avoid tunneling via expansion.
                            }
                        })

                        // Start Platform
                        this.startPlatform = this.add.rectangle(
                            GameSettings.canvas.width / 2,
                            startY + 50,
                            100,
                            20,
                            Phaser.Display.Color.HexStringToColor(GameSettings.colors.primary).color
                        )
                        this.physics.add.existing(this.startPlatform, true)
                        this.physics.add.collider(this.player, this.startPlatform)

                        // 5. Initial Level Generation
                        // Ensure the walls start from the very bottom of the screen to cover the area under the spikes
                        // We generate slightly below canvas height (e.g. + 200) to ensure spikes/death area is covered
                        this.highestGeneratedY = GameSettings.canvas.height + 200
                        this.lastChunkY = GameSettings.canvas.height + 200
                        this.generateChunk(startY - 2000)

                        // 6. Config Collisions
                        this.physics.add.collider(this.player, this.walls, (p, wall) => {
                            this.cameras.main.shake(100, 0.005)
                            this.spawnParticles(p.x, p.y)
                            this.blobCollide()
                        })
                        this.physics.add.collider(this.player, this.obstacles, (p, obstacle) => {
                            this.cameras.main.shake(100, 0.005)
                            this.shrinkObject(obstacle, true)
                            this.spawnParticles(p.x, p.y)
                            this.blobCollide()
                        })
                        this.physics.add.overlap(this.player, this.spikeContainer, this.handleDeath, null, this)
                        this.physics.add.overlap(this.player, this.coins, this.collectCoin, null, this)
                        // Pentagon collision: bounce but no damage to pentagon
                        this.physics.add.collider(this.player, this.pentagons, (p, pentagon) => {
                            this.cameras.main.shake(100, 0.008)
                            this.spawnParticles(p.x, p.y)
                            this.blobCollide()
                        })
                        // Hexagon collision: bounce off the hexagons
                        this.physics.add.collider(this.player, this.hexagons, (p, hexagon) => {
                            this.cameras.main.shake(100, 0.006)
                            this.spawnParticles(p.x, p.y)
                            this.blobCollide()
                        })
                        // Hexagon beam collision: bounce off active beams (unresistable)
                        this.physics.add.collider(this.player, this.hexagonBeams, (p, beam) => {
                            this.cameras.main.shake(150, 0.01)
                            this.spawnParticles(p.x, p.y)
                            this.blobCollide()
                            // Mark beam hit time - prevents flapping for a short duration
                            this.beamHitTime = this.time.now

                            // Amplify the bounce velocity for a stronger knockback
                            const boostFactor = 2.0
                            p.body.velocity.x *= boostFactor
                            p.body.velocity.y *= boostFactor
                        })

                        // 7. Input
                        // Note: We move manual continuous input checking to update()
                        this.input.keyboard.on('keydown-SPACE', this.flap, this)

                        // 8. UI
                        this.scoreText = this.add.text(GameSettings.canvas.width / 2, 50, '0', {
                            fontFamily: 'Arial',
                            fontSize: '48px',
                            fontStyle: 'bold',
                            color: GameSettings.colors.primary,
                            stroke: '#ffffff',
                            strokeThickness: 6
                        }).setOrigin(0.5).setScrollFactor(0).setDepth(100)

                        // Spike Chase Warning UI - positioned symmetrically left and right of score
                        const warningOffset = 120 // Distance from center to each warning symbol

                        // Left exclamation point (shown during warning phase)
                        this.warningLeftExclaim = this.add.text(
                            GameSettings.canvas.width / 2 - warningOffset, 50, '!',
                            {
                                fontFamily: 'Arial',
                                fontSize: '72px',
                                fontStyle: 'bold',
                                color: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 8
                            }
                        ).setOrigin(0.5).setScrollFactor(0).setDepth(101).setVisible(false)

                        // Right exclamation point (shown during warning phase)
                        this.warningRightExclaim = this.add.text(
                            GameSettings.canvas.width / 2 + warningOffset, 50, '!',
                            {
                                fontFamily: 'Arial',
                                fontSize: '72px',
                                fontStyle: 'bold',
                                color: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 8
                            }
                        ).setOrigin(0.5).setScrollFactor(0).setDepth(101).setVisible(false)

                        // Left warning triangle (replaces exclamation during active chase)
                        this.warningLeftTriangle = this.add.text(
                            GameSettings.canvas.width / 2 - warningOffset, 50, '⚠',
                            {
                                fontFamily: 'Arial',
                                fontSize: '96px',
                                fontStyle: 'bold',
                                color: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 8
                            }
                        ).setOrigin(0.5).setScrollFactor(0).setDepth(101).setVisible(false)

                        // Right warning triangle (replaces exclamation during active chase)
                        this.warningRightTriangle = this.add.text(
                            GameSettings.canvas.width / 2 + warningOffset, 50, '⚠',
                            {
                                fontFamily: 'Arial',
                                fontSize: '96px',
                                fontStyle: 'bold',
                                color: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 8
                            }
                        ).setOrigin(0.5).setScrollFactor(0).setDepth(101).setVisible(false)

                        this.tutorialText = this.add.text(GameSettings.canvas.width / 2, GameSettings.canvas.height / 2 + 100, 'TAP TO FLAP', {
                            fontFamily: 'Arial',
                            fontSize: '32px',
                            color: GameSettings.colors.primary
                        }).setOrigin(0.5).setDepth(20)

                        // 9. Camera setup
                        this.cameras.main.startFollow(this.player, true, 0, 0.7, 0, 200)
                        this.cameras.main.setDeadzone(0, 100)

                        // SDK Listeners
                        this.initRemixSDK()
                    }

                    // Check if running inside Remix (must be in iframe AND have Remix-specific parent)
                    isInRemix() {
                        if (!window.FarcadeSDK) return false
                        if (window.self === window.top) return false

                        // Check if parent origin matches known Remix/Farcade domains
                        try {
                            const parentOrigin = document.referrer
                            const remixDomains = ['farcade.com', 'remix.com', 'farcade.io', 'remix.io']
                            return remixDomains.some(domain => parentOrigin.includes(domain))
                        } catch (e) {
                            // If we can't check referrer, fall back to assuming not in Remix
                            return false
                        }
                    }

                    initRemixSDK() {
                        if (!window.FarcadeSDK) return

                        // Signal ready when game loads
                        if (window.FarcadeSDK.singlePlayer && window.FarcadeSDK.singlePlayer.actions) {
                            window.FarcadeSDK.singlePlayer.actions.ready()
                            console.log('Remix SDK: Game ready signal sent.')
                        }

                        // Handle play again requests from Remix
                        window.FarcadeSDK.on('play_again', () => {
                            console.log('Remix SDK: Play again requested.')
                            this.restartGame()
                        })

                        // Handle mute/unmute requests from Remix
                        window.FarcadeSDK.on('toggle_mute', (data) => {
                            console.log('Remix SDK: Mute toggle requested, isMuted:', data.isMuted)
                            // Update global mute state
                            isMusicMuted = data.isMuted
                            // Mute Phaser sound system
                            if (this.sound) this.sound.mute = data.isMuted
                            // Mute the HTML5 audio element for music
                            if (audioElement) {
                                audioElement.muted = data.isMuted
                            }
                        })

                        console.log('Remix SDK: Event handlers registered.')
                    }

                    restartGame() {
                        this.scene.restart()
                    }

                    generateTextures() {
                        // All textures generated at actual display size (no supersampling)
                        const cPrimary = Phaser.Display.Color.HexStringToColor(GameSettings.colors.primary).color
                        const cSecondary = Phaser.Display.Color.HexStringToColor(GameSettings.colors.secondary).color

                        // Player Texture - 60x60 (displayed at 1.2 scale = 72px)
                        const pG = this.make.graphics()
                        pG.fillStyle(cPrimary)
                        pG.fillCircle(30, 30, 30)
                        pG.generateTexture('player', 60, 60)
                        pG.destroy()

                        // Coin Texture (Triangle) - 45x45
                        const cG = this.make.graphics()
                        cG.fillStyle(0x000000)
                        cG.lineStyle(2, 0xffffff)
                        const coinSize = 45
                        const trianglePoints = [
                            { x: coinSize / 2, y: 0 },
                            { x: 0, y: coinSize },
                            { x: coinSize, y: coinSize }
                        ]
                        cG.fillTriangleShape(new Phaser.Geom.Triangle(trianglePoints[0].x, trianglePoints[0].y, trianglePoints[1].x, trianglePoints[1].y, trianglePoints[2].x, trianglePoints[2].y))
                        cG.strokeTriangleShape(new Phaser.Geom.Triangle(trianglePoints[0].x, trianglePoints[0].y, trianglePoints[1].x, trianglePoints[1].y, trianglePoints[2].x, trianglePoints[2].y))
                        cG.generateTexture('coin', coinSize, coinSize)
                        cG.destroy()

                        // Particle Texture - 8x8
                        const ptkG = this.make.graphics()
                        ptkG.fillStyle(0x000000)
                        ptkG.fillRect(0, 0, 8, 8)
                        ptkG.generateTexture('particle', 8, 8)
                        ptkG.destroy()

                        // Block Texture - 90x90 (actual display size)
                        const blockDisplaySize = 90
                        const wG = this.make.graphics()
                        wG.fillStyle(cPrimary)
                        wG.fillRoundedRect(0, 0, blockDisplaySize, blockDisplaySize, 24)
                        wG.generateTexture('block', blockDisplaySize, blockDisplaySize)
                        wG.destroy()

                        // Single Spike Texture - 128x128
                        const sG = this.make.graphics()
                        sG.fillStyle(Phaser.Display.Color.HexStringToColor(GameSettings.colors.hazard).color)
                        sG.fillTriangle(64, 0, 0, 128, 128, 128)
                        sG.generateTexture('spike_single', 128, 128)
                        sG.destroy()

                        // Pentagon Texture - 180x180 (2x block size)
                        const pentSize = GameSettings.obstacleTypes.pentagon.size
                        const pentG = this.make.graphics()
                        pentG.fillStyle(cPrimary)
                        const pentRadius = pentSize / 2
                        const pentCenterX = pentRadius
                        const pentCenterY = pentRadius
                        const pentPoints = []
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2
                            pentPoints.push({
                                x: pentCenterX + pentRadius * Math.cos(angle),
                                y: pentCenterY + pentRadius * Math.sin(angle)
                            })
                        }
                        pentG.beginPath()
                        pentG.moveTo(pentPoints[0].x, pentPoints[0].y)
                        for (let i = 1; i < 5; i++) {
                            pentG.lineTo(pentPoints[i].x, pentPoints[i].y)
                        }
                        pentG.closePath()
                        pentG.fillPath()
                        pentG.generateTexture('pentagon', pentSize, pentSize)
                        pentG.destroy()

                        // Hexagon Texture - black fill with white outline
                        const hexSize = GameSettings.obstacleTypes.hexagon.size
                        const hexG = this.make.graphics()
                        hexG.fillStyle(0x000000)
                        hexG.lineStyle(3, 0xffffff)
                        const hexRadius = hexSize / 2
                        const hexCenterX = hexRadius
                        const hexCenterY = hexRadius
                        const hexPoints = []
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 2 * Math.PI / 6) - Math.PI / 2
                            hexPoints.push({
                                x: hexCenterX + hexRadius * 0.9 * Math.cos(angle),
                                y: hexCenterY + hexRadius * 0.9 * Math.sin(angle)
                            })
                        }
                        hexG.beginPath()
                        hexG.moveTo(hexPoints[0].x, hexPoints[0].y)
                        for (let i = 1; i < 6; i++) {
                            hexG.lineTo(hexPoints[i].x, hexPoints[i].y)
                        }
                        hexG.closePath()
                        hexG.fillPath()
                        hexG.strokePath()
                        hexG.generateTexture('hexagon', hexSize, hexSize)
                        hexG.destroy()

                        // BG Texture 1: Far Layer - 1024x2048
                        const texW = 1024
                        const texH = 2048
                        const texCenter = texW / 2

                        const farCanvas = document.createElement('canvas')
                        farCanvas.width = texW
                        farCanvas.height = texH
                        const farCtx = farCanvas.getContext('2d')

                        farCtx.fillStyle = '#ffffff'
                        farCtx.fillRect(0, 0, texW, texH)

                        farCtx.fillStyle = '#d0d0d0'
                        const farCenterBandW = 240
                        const farTowerW = 120
                        const farTowerDist = 360

                        farCtx.fillRect(texCenter - (farCenterBandW / 2), 0, farCenterBandW, texH)
                        farCtx.fillRect(texCenter - farTowerDist - farTowerW, 0, farTowerW, texH)
                        farCtx.fillRect(texCenter + farTowerDist, 0, farTowerW, texH)

                        const archH = 280
                        const archGap = 400
                        const archBridgeHeight = 240
                        const archCurveRadius = 320

                        for (let y = 200; y < texH; y += (archH + archGap)) {
                            const bridgeBottom = y + archBridgeHeight

                            const leftStart = texCenter - farTowerDist
                            const leftEnd = texCenter - (farCenterBandW / 2)
                            const leftWidth = leftEnd - leftStart

                            farCtx.beginPath()
                            farCtx.moveTo(leftStart, y)
                            farCtx.lineTo(leftEnd, y)
                            farCtx.lineTo(leftEnd, bridgeBottom)
                            farCtx.quadraticCurveTo(leftStart + leftWidth / 2, bridgeBottom - archCurveRadius, leftStart, bridgeBottom)
                            farCtx.closePath()
                            farCtx.fill()

                            const rightStart = texCenter + (farCenterBandW / 2)
                            const rightEnd = texCenter + farTowerDist
                            const rightWidth = rightEnd - rightStart

                            farCtx.beginPath()
                            farCtx.moveTo(rightStart, y)
                            farCtx.lineTo(rightEnd, y)
                            farCtx.lineTo(rightEnd, bridgeBottom)
                            farCtx.quadraticCurveTo(rightStart + rightWidth / 2, bridgeBottom - archCurveRadius, rightStart, bridgeBottom)
                            farCtx.closePath()
                            farCtx.fill()
                        }

                        const farImageData = farCtx.getImageData(0, 0, texW, texH)
                        const farData = farImageData.data
                        for (let i = 0; i < farData.length; i += 4) {
                            if (farData[i] === 255 && farData[i + 1] === 255 && farData[i + 2] === 255) {
                                farData[i + 3] = 0
                            }
                        }
                        farCtx.putImageData(farImageData, 0, 0)
                        this.textures.addCanvas('bg_far', farCanvas)

                        // BG Texture 2: Mid Layer - 1024x2048
                        const midCanvas = document.createElement('canvas')
                        midCanvas.width = texW
                        midCanvas.height = texH
                        const midCtx = midCanvas.getContext('2d')

                        midCtx.fillStyle = '#ffffff'
                        midCtx.fillRect(0, 0, texW, texH)

                        midCtx.fillStyle = '#b0b0b0'
                        const midCenterBandW = 160
                        const midTowerWLeft = 120
                        const midTowerWRight = 120
                        const midTowerDist = 400

                        midCtx.fillRect(texCenter - (midCenterBandW / 2), 0, midCenterBandW, texH)
                        midCtx.fillRect(texCenter - midTowerDist - midTowerWLeft, 0, midTowerWLeft, texH)
                        midCtx.fillRect(texCenter + midTowerDist, 0, midTowerWRight, texH)

                        const midArchH = 500
                        const midArchGap = 700
                        const bridgeHeight = 240
                        const curveRadius = 320

                        for (let y = 0; y < texH; y += (midArchH + midArchGap)) {
                            const bridgeBottom = y + bridgeHeight

                            const leftStart = texCenter - midTowerDist
                            const leftEnd = texCenter - (midCenterBandW / 2)
                            const leftWidth = leftEnd - leftStart

                            midCtx.beginPath()
                            midCtx.moveTo(leftStart, y)
                            midCtx.lineTo(leftEnd, y)
                            midCtx.lineTo(leftEnd, bridgeBottom)
                            midCtx.quadraticCurveTo(leftStart + leftWidth / 2, bridgeBottom - curveRadius, leftStart, bridgeBottom)
                            midCtx.closePath()
                            midCtx.fill()

                            const rightStart = texCenter + (midCenterBandW / 2)
                            const rightEnd = texCenter + midTowerDist
                            const rightWidth = rightEnd - rightStart

                            midCtx.beginPath()
                            midCtx.moveTo(rightStart, y)
                            midCtx.lineTo(rightEnd, y)
                            midCtx.lineTo(rightEnd, bridgeBottom)
                            midCtx.quadraticCurveTo(rightStart + rightWidth / 2, bridgeBottom - curveRadius, rightStart, bridgeBottom)
                            midCtx.closePath()
                            midCtx.fill()
                        }

                        const midImageData = midCtx.getImageData(0, 0, texW, texH)
                        const midData = midImageData.data
                        for (let i = 0; i < midData.length; i += 4) {
                            if (midData[i] === 255 && midData[i + 1] === 255 && midData[i + 2] === 255) {
                                midData[i + 3] = 0
                            }
                        }
                        midCtx.putImageData(midImageData, 0, 0)
                        this.textures.addCanvas('bg_mid', midCanvas)

                        // BG Texture 3: Near Layer (Removed for architectural consistency per instructions)
                        const bgNearG = this.make.graphics()
                        bgNearG.generateTexture('bg_near', 1, 1) // Empty placeholder
                        bgNearG.destroy()
                    }

                    flap() {
                        if (this.isGameOver) return

                        const now = this.time.now

                        // Prevent flapping if recently hit by beam (let bounce complete)
                        const beamStunDuration = 400 // ms
                        if (now - this.beamHitTime < beamStunDuration) {
                            return
                        }

                        if (now - this.lastFlapTime < this.flapCooldown) {
                            return
                        }
                        this.lastFlapTime = now

                        if (!this.hasStarted) {
                            this.hasStarted = true
                            this.tutorialText.destroy()

                            // Start music on first interaction
                            startMusic()

                            // Remove start platform after a brief delay so player doesn't land back on it
                            this.time.delayedCall(1000, () => {
                                if (this.startPlatform) this.startPlatform.destroy()
                            })
                        }

                        // Upward force
                        this.player.setVelocityY(-GameSettings.gameplay.jumpForce)

                        // Horizontal force
                        const xVel = GameSettings.gameplay.horizontalSpeed * this.nextFlapDirection
                        this.player.setVelocityX(xVel)

                        // Flip sprite visually towards direction
                        if (this.nextFlapDirection === 1) {
                            this.player.setFlipX(false)
                            this.nextFlapDirection = -1
                        } else {
                            this.player.setFlipX(true)
                            this.nextFlapDirection = 1
                        }

                        // Enhanced Blobby Jump: Organic squish/stretch
                        const jumpDuration = 120
                        const stretchY = 1.6
                        const squishX = 0.6
                        const slant = (Math.random() - 0.5) * 30

                        this.tweens.killTweensOf(this.player)

                        // Using chain for modern, robust tween sequence
                        this.tweens.chain({
                            targets: this.player,
                            tweens: [
                                {
                                    scaleX: squishX,
                                    scaleY: stretchY,
                                    angle: slant,
                                    duration: jumpDuration,
                                    ease: 'Sine.easeOut',
                                    onUpdate: () => this.player.emit('scale_update')
                                },
                                {
                                    scaleX: 1.3,
                                    scaleY: 0.8,
                                    angle: -slant * 0.5,
                                    duration: jumpDuration * 1.5,
                                    ease: 'Quad.easeInOut',
                                    onUpdate: () => this.player.emit('scale_update')
                                },
                                {
                                    scaleX: 1.2,
                                    scaleY: 1.2,
                                    angle: 0,
                                    duration: 400,
                                    ease: 'Elastic.easeOut',
                                    easeParams: [1, 0.5],
                                    onUpdate: () => this.player.emit('scale_update')
                                }
                            ]
                        })
                    }

                    blobCollide() {
                        if (this.isGameOver) return

                        // More organic, elastic collision squish
                        const dir = this.player.body.velocity.x > 0 ? 1 : -1
                        const impactIntensity = Phaser.Math.Clamp(Math.abs(this.player.body.velocity.x) / 300, 0.4, 1.2)

                        this.tweens.killTweensOf(this.player)
                        this.tweens.chain({
                            targets: this.player,
                            tweens: [
                                {
                                    scaleX: 1.2 + (0.5 * impactIntensity),
                                    scaleY: 1.2 - (0.4 * impactIntensity),
                                    angle: (20 * impactIntensity) * dir,
                                    duration: 80,
                                    ease: 'Quad.easeOut',
                                    onUpdate: () => this.player.emit('scale_update')
                                },
                                {
                                    scaleX: 1.2,
                                    scaleY: 1.2,
                                    angle: 0,
                                    duration: 500,
                                    ease: 'Elastic.easeOut',
                                    easeParams: [1, 0.4],
                                    onUpdate: () => this.player.emit('scale_update')
                                }
                            ]
                        })
                    }

                    collectCoin(player, coin) {
                        const cx = coin.x
                        const cy = coin.y
                        coin.destroy()
                        this.score += 4
                        this.scoreText.setText(this.score.toString())

                        // Feedback: Dual expanding fading shockwaves (White and Black)
                        const shockWhite = this.add.circle(cx, cy, 10, 0xffffff, 0)
                        shockWhite.setStrokeStyle(3, 0xffffff)
                        const shockBlack = this.add.circle(cx, cy, 10, 0x000000, 0)
                        shockBlack.setStrokeStyle(3, 0x000000)

                        // White Shockwave
                        this.tweens.add({
                            targets: shockWhite,
                            radius: 120,
                            alpha: { from: 1, to: 0 },
                            duration: 450,
                            ease: 'Quad.easeOut',
                            onComplete: () => shockWhite.destroy()
                        })

                        // Black Shockwave (slightly delayed and different size for visibility)
                        this.tweens.add({
                            targets: shockBlack,
                            radius: 140,
                            alpha: { from: 1, to: 0 },
                            delay: 50,
                            duration: 500,
                            ease: 'Quad.easeOut',
                            onComplete: () => shockBlack.destroy()
                        })

                        // Visual feedback
                        this.tweens.add({
                            targets: this.scoreText,
                            scale: 1.2,
                            duration: 100,
                            yoyo: true
                        })
                    }

                    spawnParticles(x, y) {
                        // Instant spawn with significant upward and outward force
                        for (let i = 0; i < 10; i++) {
                            const p = this.add.image(x, y, 'particle')

                            this.physics.add.existing(p)

                            // Burst logic: Upward bias (-200 to -600 range) and wide spread
                            const vx = (Math.random() - 0.5) * 600
                            const vy = -Math.random() * 400 - 200

                            p.body.setVelocity(vx, vy)
                            p.body.setGravityY(1400) // Snap them back down quickly

                            this.tweens.add({
                                targets: p,
                                alpha: 0,
                                scale: 0.1,
                                angle: Math.random() * 360,
                                duration: 600,
                                ease: 'Cubic.easeIn',
                                onComplete: () => p.destroy()
                            })
                        }
                    }

                    // Calculate the current player altitude in meters
                    getPlayerAltitude() {
                        const startY = GameSettings.canvas.height - 200
                        return Math.max(0, Math.floor(startY - this.player.y))
                    }

                    // Spawn a full row of square obstacles at a given Y position
                    spawnFullRowOfSquares(y) {
                        const width = GameSettings.canvas.width
                        const wallThick = GameSettings.gameplay.wallThickness
                        const blockSize = GameSettings.gameplay.obstacleSize
                        const gap = 52 // Gap sized to fit 6-7 normal blocks

                        // Calculate how many blocks fit across the playable area with gaps
                        const playableWidth = width - (wallThick * 2)
                        // (count * blockSize) + ((count - 1) * gap) <= playableWidth
                        // count * (blockSize + gap) - gap <= playableWidth
                        const blocksCount = Math.floor((playableWidth + gap) / (blockSize + gap))

                        const totalBlocksWidth = (blocksCount * blockSize) + ((blocksCount - 1) * gap)
                        const startX = wallThick + (playableWidth - totalBlocksWidth) / 2 + blockSize / 2

                        for (let i = 0; i < blocksCount; i++) {
                            const x = startX + i * (blockSize + gap)
                            const block = this.obstacles.create(x, y, 'block')
                            block.body.updateFromGameObject()
                            block.refreshBody()
                        }

                        console.log(`[INTERVAL] Spawned full row of ${blocksCount} squares at Y=${y} with ${gap}px gaps`)
                    }

                    // Spawn columns of 4 coins above a given Y position based on interval number
                    // Interval 1: 1 column, Interval 2: 2 columns, Interval 5: 5 columns, etc. (no reset)
                    spawnIntervalCoinColumns(baseY, intervalNumber) {
                        const width = GameSettings.canvas.width
                        const wallThick = GameSettings.gameplay.wallThickness
                        const coinSize = GameSettings.gameplay.obstacleSize
                        const coinSpacing = coinSize + 20

                        // Number of columns equals the interval number (no reset)
                        const numColumns = intervalNumber

                        // Calculate playable width
                        const playableWidth = width - (wallThick * 2)

                        // Calculate column positions - distribute evenly across playable width
                        const columnPositions = []
                        if (numColumns === 1) {
                            // Single column in the middle
                            columnPositions.push(width / 2)
                        } else {
                            // Distribute columns evenly using full width
                            const spacing = playableWidth / (numColumns + 1)
                            for (let c = 0; c < numColumns; c++) {
                                columnPositions.push(wallThick + spacing * (c + 1))
                            }
                        }

                        let totalCoins = 0

                        // Spawn 4 coins vertically for each column
                        for (const colX of columnPositions) {
                            for (let row = 0; row < 4; row++) {
                                const coinY = baseY - (row + 1) * coinSpacing
                                const coin = this.coins.create(colX, coinY, 'coin')
                                coin.setDisplaySize(coinSize, coinSize)
                                // Hitbox is 2x display size for easier collection
                                const textureSize = coinSize
                                const hitboxSize = textureSize * 2
                                coin.body.setSize(hitboxSize, hitboxSize)
                                coin.body.setOffset((textureSize - hitboxSize) / 2, (textureSize - hitboxSize) / 2)
                                this.tweens.add({
                                    targets: coin,
                                    angle: 360,
                                    duration: 1200,
                                    repeat: -1
                                })
                                totalCoins++
                            }
                        }

                        console.log(`[INTERVAL] Spawned ${numColumns} column(s) of 4 coins (${totalCoins} total) above Y=${baseY}`)
                    }

                    // Update spike warning UI based on distance from player
                    updateSpikeWarning(time) {
                        // Calculate distance from spikes to player (in Phaser, higher Y = lower on screen)
                        const spikeDistance = this.spikeContainer.y - this.player.y

                        // Determine warning level based on distance
                        let newLevel = 0
                        if (spikeDistance < 1000) {
                            newLevel = 2  // Danger - very close
                        } else if (spikeDistance < 2000) {
                            newLevel = 1  // Caution - getting close
                        }

                        // Handle level transitions
                        if (newLevel !== this.spikeWarningLevel) {
                            this.spikeWarningLevel = newLevel

                            // Update visibility based on level
                            if (newLevel === 0) {
                                // Safe - hide all warnings
                                this.warningLeftExclaim.setVisible(false)
                                this.warningRightExclaim.setVisible(false)
                                this.warningLeftTriangle.setVisible(false)
                                this.warningRightTriangle.setVisible(false)
                            } else if (newLevel === 1) {
                                // Caution - show blinking exclamation points
                                this.warningLeftExclaim.setVisible(true)
                                this.warningRightExclaim.setVisible(true)
                                this.warningLeftTriangle.setVisible(false)
                                this.warningRightTriangle.setVisible(false)
                            } else if (newLevel === 2) {
                                // Danger - show pulsing warning triangles
                                this.warningLeftExclaim.setVisible(false)
                                this.warningRightExclaim.setVisible(false)
                                this.warningLeftTriangle.setVisible(true)
                                this.warningRightTriangle.setVisible(true)
                            }
                        }

                        // Animate based on current level
                        if (this.spikeWarningLevel === 1) {
                            // Blink exclamation points (toggle every 250ms)
                            const blinkOn = Math.floor(time / 250) % 2 === 0
                            this.warningLeftExclaim.setVisible(blinkOn)
                            this.warningRightExclaim.setVisible(blinkOn)
                        } else if (this.spikeWarningLevel === 2) {
                            // Pulse warning triangles (scale 0.8 to 1.2, 200ms cycle)
                            const pulseScale = 1.0 + 0.2 * Math.sin(time / 200 * Math.PI)
                            this.warningLeftTriangle.setScale(pulseScale)
                            this.warningRightTriangle.setScale(pulseScale)

                            // Also pulse alpha
                            const pulseAlpha = 0.7 + 0.3 * Math.sin(time / 150 * Math.PI)
                            this.warningLeftTriangle.setAlpha(pulseAlpha)
                            this.warningRightTriangle.setAlpha(pulseAlpha)
                        }
                    }

                    // Reset spike warning UI
                    resetSpikeWarning() {
                        this.spikeWarningLevel = 0

                        // Hide all warning UI
                        this.warningLeftExclaim.setVisible(false)
                        this.warningRightExclaim.setVisible(false)
                        this.warningLeftTriangle.setVisible(false)
                        this.warningRightTriangle.setVisible(false)

                        // Reset scales and alpha
                        this.warningLeftExclaim.setScale(1).setAlpha(1)
                        this.warningRightExclaim.setScale(1).setAlpha(1)
                        this.warningLeftTriangle.setScale(1).setAlpha(1)
                        this.warningRightTriangle.setScale(1).setAlpha(1)
                    }

                    // Handle reaching an interval milestone
                    handleIntervalReached(intervalAltitude) {
                        console.log(`[INTERVAL] ===== PLAYER REACHED INTERVAL at ${intervalAltitude}m =====`)

                        // Convert altitude to Y coordinate
                        const startY = GameSettings.canvas.height - 200
                        const intervalY = startY - intervalAltitude

                        // Update the last interval
                        this.lastIntervalAltitude = intervalAltitude

                        // Move to next interval (do this first to get correct interval number)
                        this.nextIntervalIndex++
                        const currentIntervalNumber = this.nextIntervalIndex // 1-indexed interval number

                        // Check if we just completed a 4-interval cycle (intervals 4, 8, 12, etc.)
                        if (currentIntervalNumber % 4 === 0) {
                            // Completed a cycle - increase hazard speed by 50
                            const cycleNumber = Math.floor(currentIntervalNumber / 4)
                            GameSettings.gameplay.hazardSpeed = GameSettings.gameplay.baseHazardSpeed + (cycleNumber * 50)
                            console.log(`[INTERVAL] Completed cycle ${cycleNumber}! Hazard speed now: ${GameSettings.gameplay.hazardSpeed}`)
                        }

                        // Always teleport spikes 1000m below player on interval break
                        const safeguardDistance = 1000
                        const targetSpikeY = this.player.y + safeguardDistance
                        this.surgeTargetY = targetSpikeY
                        this.spikeContainer.y = targetSpikeY
                        console.log(`[INTERVAL] Teleporting spikes 1000m below player (Y=${targetSpikeY})`)

                        // Reset spike warning UI
                        this.resetSpikeWarning()

                        console.log(`[INTERVAL] Next interval: ${this.intervalAltitudes[this.nextIntervalIndex] || 'none'}m`)

                        // Visual feedback - screen flash
                        this.cameras.main.flash(300, 255, 255, 255)
                    }

                    generateChunk(targetY) {
                        const width = GameSettings.canvas.width
                        const wallThick = GameSettings.gameplay.wallThickness
                        const screenHeight = GameSettings.canvas.height
                        const startY = screenHeight - 200 // Player start position

                        // Process walls and obstacles screen by screen for density logic
                        while (this.lastChunkY > targetY) {
                            const chunkBottom = this.lastChunkY
                            const chunkTop = chunkBottom - screenHeight

                            // Calculate altitude range for this chunk
                            const chunkBottomAltitude = Math.max(0, startY - chunkBottom)
                            const chunkTopAltitude = Math.max(0, startY - chunkTop)

                            // 1. Generate Walls for this screen-sized chunk
                            for (let y = chunkBottom; y > chunkTop; y -= wallThick) {
                                const leftWall = this.walls.create(wallThick / 2, y, 'block')
                                leftWall.setDisplaySize(wallThick, wallThick)
                                leftWall.refreshBody()

                                const rightWall = this.walls.create(width - wallThick / 2, y, 'block')
                                rightWall.setDisplaySize(wallThick, wallThick)
                                rightWall.refreshBody()
                            }

                            // 2. Check if any interval barriers should be generated in this chunk
                            for (let i = 0; i < this.intervalAltitudes.length; i++) {
                                const intervalAlt = this.intervalAltitudes[i]
                                if (intervalAlt >= chunkBottomAltitude && intervalAlt <= chunkTopAltitude) {
                                    if (!this.generatedIntervalBarriers.has(intervalAlt)) {
                                        this.generatedIntervalBarriers.add(intervalAlt)
                                        const intervalY = startY - intervalAlt

                                        // Interval number is 1-indexed (i + 1)
                                        const intervalNumber = i + 1

                                        // Spawn full row of squares at the interval point
                                        this.spawnFullRowOfSquares(intervalY)

                                        // Spawn coin columns above the squares (1-4 columns based on interval)
                                        this.spawnIntervalCoinColumns(intervalY - GameSettings.gameplay.obstacleSize, intervalNumber)

                                        console.log(`[INTERVAL] Pre-generated barrier at ${intervalAlt}m (Y=${intervalY})`)
                                    }
                                }
                            }

                            // 3. Calculate interval-based spawn rates
                            // Determine which interval we're in (1-indexed)
                            // intervalsPassedForChunk = 0 means we're in interval 1 (0-10000m)
                            // intervalsPassedForChunk = 1 means we're in interval 2 (10000-20000m), etc.
                            let intervalsPassedForChunk = 0
                            for (let i = 0; i < this.intervalAltitudes.length; i++) {
                                if (chunkTopAltitude > this.intervalAltitudes[i]) {
                                    intervalsPassedForChunk++
                                } else {
                                    break
                                }
                            }

                            // intervalNumber is 1-indexed (interval 1, 2, 3, ...)
                            const intervalNumber = intervalsPassedForChunk + 1

                            // For BLOCKS: cycle position resets every 4 intervals (1, 2, 3, 4, 1, 2, 3, 4, ...)
                            const blockCyclePosition = ((intervalNumber - 1) % 4) + 1

                            // Block spawn rate: X + X * cycle_position (where X = 2)
                            // Interval 1: 4, Interval 2: 6, Interval 3: 8, Interval 4: 10, then resets
                            const baseBlockRate = 2
                            const blocksPerScreen = baseBlockRate + (baseBlockRate * blockCyclePosition)

                            // For COINS: 8 * intervalNumber per full 10000m interval (does NOT reset)
                            // Calculate coins per screen based on how many screens fit in an interval
                            const screensPerInterval = 10000 / screenHeight
                            const totalCoinsForInterval = 8 * intervalNumber
                            const coinsPerScreen = totalCoinsForInterval / screensPerInterval

                            const minX = wallThick + 10
                            const maxX = width - wallThick - 10
                            const minDist = 80

                            // Spawn Blocks
                            let blocksSpawned = 0
                            let blockAttempts = 0
                            while (blocksSpawned < blocksPerScreen && blockAttempts < 100) {
                                blockAttempts++
                                const rx = Phaser.Math.Between(minX, maxX)
                                const ry = Phaser.Math.Between(chunkTop, chunkBottom)

                                if (this.isSpaceClear(rx, ry, minDist)) {
                                    const block = this.obstacles.create(rx, ry, 'block')
                                    block.refreshBody()
                                    blocksSpawned++
                                }
                            }

                            // Independent Coin Spawning (use Math.round for fractional coins per screen)
                            const coinsToSpawn = Math.round(coinsPerScreen)
                            let coinsSpawned = 0
                            let coinAttempts = 0
                            while (coinsSpawned < coinsToSpawn && coinAttempts < 100) {
                                coinAttempts++
                                const rx = Phaser.Math.Between(minX, maxX)
                                const ry = Phaser.Math.Between(chunkTop, chunkBottom)

                                // Coins can be closer to objects than other objects
                                if (this.isSpaceClear(rx, ry, 40)) {
                                    const coin = this.coins.create(rx, ry, 'coin')
                                    coin.setDisplaySize(GameSettings.gameplay.obstacleSize, GameSettings.gameplay.obstacleSize)
                                    // Hitbox is 2x display size for easier collection
                                    const textureSize = GameSettings.gameplay.obstacleSize
                                    const hitboxSize = textureSize * 2
                                    coin.body.setSize(hitboxSize, hitboxSize)
                                    coin.body.setOffset((textureSize - hitboxSize) / 2, (textureSize - hitboxSize) / 2)
                                    this.tweens.add({
                                        targets: coin,
                                        angle: 360,
                                        duration: 1200,
                                        repeat: -1
                                    })
                                    coinsSpawned++
                                }
                            }

                            // Spawn interval-gated obstacles (pentagons, etc.)
                            this.spawnIntervalGatedObstacles(intervalNumber, chunkTop, chunkBottom, minX, maxX)

                            this.lastChunkY = chunkTop
                            this.highestGeneratedY = chunkTop
                        }
                    }

                    isSpaceClear(x, y, minDist) {
                        const minDistSq = minDist * minDist
                        let isClear = true

                        // Only need to check obstacles near the Y coordinate
                        this.obstacles.children.each(obs => {
                            if (!obs.active) return
                            const dx = x - obs.x
                            const dy = y - obs.y
                            if ((dx * dx + dy * dy) < minDistSq) {
                                isClear = false
                            }
                        })

                        // Also check against coins to avoid weird overlapping clusters
                        this.coins.children.each(coin => {
                            if (!coin.active) return
                            const dx = x - coin.x
                            const dy = y - coin.y
                            if ((dx * dx + dy * dy) < minDistSq * 0.5) {
                                isClear = false
                            }
                        })

                        // Also check against pentagons (larger clearance)
                        this.pentagons.children.each(pentagon => {
                            if (!pentagon.active) return
                            const dx = x - pentagon.x
                            const dy = y - pentagon.y
                            const pentagonMinDistSq = (minDist + GameSettings.obstacleTypes.pentagon.size / 2) ** 2
                            if ((dx * dx + dy * dy) < pentagonMinDistSq) {
                                isClear = false
                            }
                        })

                        // Also check against hexagons
                        this.hexagons.children.each(hexagon => {
                            if (!hexagon.active) return
                            const dx = x - hexagon.x
                            const dy = y - hexagon.y
                            const hexagonMinDistSq = (minDist + GameSettings.obstacleTypes.hexagon.size / 2) ** 2
                            if ((dx * dx + dy * dy) < hexagonMinDistSq) {
                                isClear = false
                            }
                        })

                        return isClear
                    }

                    // Generic spawner for interval-gated obstacles
                    spawnIntervalGatedObstacles(currentInterval, chunkTop, chunkBottom, minX, maxX) {
                        const obstacleTypes = GameSettings.obstacleTypes

                        for (const [typeName, config] of Object.entries(obstacleTypes)) {
                            // Skip if current interval is before this obstacle's start interval
                            if (currentInterval < config.startInterval) continue

                            // Calculate spawn count for this chunk
                            // Distribute spawns across the interval (10 screens per interval roughly)
                            const screensPerInterval = 10000 / GameSettings.canvas.height
                            const [minSpawn, maxSpawn] = config.spawnRate
                            const avgPerInterval = (minSpawn + maxSpawn) / 2
                            const spawnChance = avgPerInterval / screensPerInterval

                            // Spawn with probability, or guaranteed 1 if chance > 1
                            const toSpawn = Math.random() < spawnChance ? 1 : 0

                            if (toSpawn > 0) {
                                this.spawnObstacleByType(typeName, config, chunkTop, chunkBottom, minX, maxX)
                            }
                        }
                    }

                    // Spawn a specific obstacle type
                    spawnObstacleByType(typeName, config, chunkTop, chunkBottom, minX, maxX) {
                        const size = config.size || 90
                        // Adjust spawn bounds for larger obstacles
                        const adjustedMinX = minX + size / 2
                        const adjustedMaxX = maxX - size / 2

                        let attempts = 0
                        while (attempts < 50) {
                            attempts++
                            const rx = Phaser.Math.Between(adjustedMinX, adjustedMaxX)
                            const ry = Phaser.Math.Between(chunkTop, chunkBottom)

                            // Larger clearance for bigger obstacles
                            if (this.isSpaceClear(rx, ry, size + 40)) {
                                if (typeName === 'pentagon') {
                                    this.spawnPentagon(rx, ry, config)
                                } else if (typeName === 'hexagon') {
                                    this.spawnHexagonPair(ry, config)
                                }
                                break
                            }
                        }
                    }

                    // Spawn a pentagon obstacle
                    spawnPentagon(x, y, config) {
                        const pentagon = this.pentagons.create(x, y, 'pentagon')
                        const size = config.size

                        // Set display size
                        pentagon.setDisplaySize(size, size)

                        // Configure physics body - circular for pentagon
                        // setCircle(radius) - no offset needed when texture and body are same size
                        pentagon.body.setCircle(size / 2)

                        // Set constant downward velocity
                        pentagon.body.setVelocityY(config.moveSpeed)

                        // Store rotation config on the object
                        pentagon.rotationRange = config.rotationRange
                        pentagon.rotationSpeed = config.rotationSpeed
                        pentagon.spawnTime = this.time.now

                        console.log(`[OBSTACLE] Spawned pentagon at (${x}, ${y})`)
                    }

                    // Spawn a hexagon pair on opposite walls
                    spawnHexagonPair(y, config) {
                        const wallThick = GameSettings.gameplay.wallThickness
                        const size = config.size
                        const halfSize = size / 2

                        // Left hexagon - center positioned on the wall edge (part outside game window)
                        const leftX = wallThick
                        const leftHex = this.hexagons.create(leftX, y, 'hexagon')
                        leftHex.setDisplaySize(size, size)
                        leftHex.refreshBody()

                        // Right hexagon - center positioned on the wall edge (part outside game window)
                        const rightX = GameSettings.canvas.width - wallThick
                        const rightHex = this.hexagons.create(rightX, y, 'hexagon')
                        rightHex.setDisplaySize(size, size)
                        rightHex.refreshBody()

                        // Create the pair data structure
                        const pairData = {
                            left: leftHex,
                            right: rightHex,
                            y: y,
                            spawnTime: this.time.now,
                            state: 'recharging', // 'recharging', 'spinning', 'firing'
                            stateStartTime: this.time.now,
                            beam: null,
                            beamGraphics: null,
                            config: config
                        }

                        // Store reference to pair on each hexagon
                        leftHex.pairData = pairData
                        rightHex.pairData = pairData

                        // Add to tracking array
                        this.hexagonPairs.push(pairData)

                        console.log(`[OBSTACLE] Spawned hexagon pair at Y=${y}`)
                    }

                    // Update hexagon pairs (called in main update loop)
                    updateHexagonPairs(time) {
                        const config = GameSettings.obstacleTypes.hexagon
                        const rechargeDuration = config.rechargeDuration
                        const spinDuration = config.spinDuration
                        const fireDuration = config.fireDuration
                        const totalCycle = rechargeDuration + fireDuration

                        for (let i = this.hexagonPairs.length - 1; i >= 0; i--) {
                            const pair = this.hexagonPairs[i]

                            // Check if hexagons are still active
                            if (!pair.left.active || !pair.right.active) {
                                // Clean up beam if exists
                                if (pair.beam) {
                                    pair.beam.destroy()
                                    pair.beam = null
                                }
                                if (pair.beamGraphics) {
                                    pair.beamGraphics.destroy()
                                    pair.beamGraphics = null
                                }
                                this.hexagonPairs.splice(i, 1)
                                continue
                            }

                            const cycleTime = (time - pair.spawnTime) % totalCycle

                            // Determine state based on cycle time
                            // 0 to rechargeDuration-spinDuration: recharging (not spinning)
                            // rechargeDuration-spinDuration to rechargeDuration: spinning (about to fire)
                            // rechargeDuration to totalCycle: firing

                            if (cycleTime < rechargeDuration - spinDuration) {
                                // Recharging state (no spin)
                                if (pair.state !== 'recharging') {
                                    pair.state = 'recharging'
                                    // Destroy beam when switching to recharge
                                    if (pair.beam) {
                                        pair.beam.destroy()
                                        pair.beam = null
                                    }
                                    if (pair.beamGraphics) {
                                        pair.beamGraphics.destroy()
                                        pair.beamGraphics = null
                                    }
                                }
                                // Reset rotation
                                pair.left.angle = 0
                                pair.right.angle = 0
                            } else if (cycleTime < rechargeDuration) {
                                // Spinning state (about to fire)
                                if (pair.state !== 'spinning') {
                                    pair.state = 'spinning'
                                }
                                // Calculate spin progress (0 to 1)
                                const spinProgress = (cycleTime - (rechargeDuration - spinDuration)) / spinDuration
                                // Accelerating spin - starts slow, ends fast
                                const spinAngle = spinProgress * spinProgress * 720 // Two full rotations, accelerating
                                pair.left.angle = spinAngle
                                pair.right.angle = -spinAngle // Opposite direction
                            } else {
                                // Firing state
                                if (pair.state !== 'firing') {
                                    pair.state = 'firing'
                                    // Create the beam
                                    this.createHexagonBeam(pair)
                                }
                                // Keep spinning slowly while firing
                                const fireProgress = (cycleTime - rechargeDuration) / fireDuration
                                pair.left.angle = 720 + fireProgress * 180
                                pair.right.angle = -720 - fireProgress * 180

                                // Update beam graphics (animated lines)
                                this.updateBeamGraphics(pair, time)
                            }
                        }
                    }

                    // Create the laser beam between hexagon pair
                    createHexagonBeam(pair) {
                        const halfSize = pair.config.size / 2
                        // Beam starts from the edge of each hexagon
                        const leftX = pair.left.x + halfSize
                        const rightX = pair.right.x - halfSize
                        const beamWidth = rightX - leftX
                        const beamHeight = 25 // Base height (will pulse 20-30)

                        // Create physics body for collision
                        const beam = this.add.rectangle(
                            (leftX + rightX) / 2,
                            pair.y,
                            beamWidth,
                            beamHeight,
                            0xffffff
                        )
                        beam.setStrokeStyle(2, 0x000000)

                        this.physics.add.existing(beam, true) // Static body
                        this.hexagonBeams.add(beam)

                        pair.beam = beam

                        // Create graphics object for animated lines
                        pair.beamGraphics = this.add.graphics()
                        pair.beamGraphics.setDepth(5)
                    }

                    // Update beam graphics with animated gray lines
                    updateBeamGraphics(pair, time) {
                        if (!pair.beam || !pair.beamGraphics) return

                        const graphics = pair.beamGraphics
                        graphics.clear()

                        const halfSize = pair.config.size / 2
                        const leftX = pair.left.x + halfSize
                        const rightX = pair.right.x - halfSize
                        const centerX = (leftX + rightX) / 2
                        const centerY = pair.y

                        // Pulse the beam height between 20 and 30 - 4 pulses over fire duration
                        const fireDuration = pair.config.fireDuration
                        const cycleTime = (time - pair.spawnTime) % (pair.config.rechargeDuration + fireDuration)
                        const fireStartTime = pair.config.rechargeDuration
                        const timeIntoFire = cycleTime - fireStartTime

                        // 4 pulses over fireDuration
                        const pulseProgress = (timeIntoFire / fireDuration) * 4 * Math.PI * 2
                        const pulseAmount = Math.sin(pulseProgress) * 5 // Pulse +/- 5 pixels
                        const beamHeight = 25 + pulseAmount // Oscillates between 20 and 30

                        // Update the beam rectangle size
                        pair.beam.setSize(rightX - leftX, beamHeight)
                        pair.beam.body.setSize(rightX - leftX, beamHeight)

                        // New effect: small energy dashes converging toward center
                        graphics.lineStyle(2, 0x888888, 0.5)

                        const speed = 0.4 // Fast movement
                        const dashLength = 20
                        const dashSpacing = 60
                        const halfBeam = (rightX - leftX) / 2

                        // Create several "lanes" of dashes at different Y offsets
                        const lanes = [-6, 0, 6]

                        for (let laneIdx = 0; laneIdx < lanes.length; laneIdx++) {
                            const yOffset = lanes[laneIdx]
                            const yPos = centerY + yOffset

                            // Stagger timing per lane
                            const laneTimeOffset = laneIdx * 200
                            const progress = ((time + laneTimeOffset) * speed) % dashSpacing

                            // Dashes coming from left side
                            for (let d = 0; d < 6; d++) {
                                const dashX = leftX + progress + (d * dashSpacing)
                                if (dashX > leftX && dashX + dashLength < centerX) {
                                    graphics.beginPath()
                                    graphics.moveTo(dashX, yPos)
                                    graphics.lineTo(dashX + dashLength, yPos)
                                    graphics.strokePath()
                                }
                            }

                            // Dashes coming from right side
                            for (let d = 0; d < 6; d++) {
                                const dashX = rightX - progress - (d * dashSpacing)
                                if (dashX < rightX && dashX - dashLength > centerX) {
                                    graphics.beginPath()
                                    graphics.moveTo(dashX, yPos)
                                    graphics.lineTo(dashX - dashLength, yPos)
                                    graphics.strokePath()
                                }
                            }
                        }
                    }

                    spawnCoinNear(targetX, targetY) {
                        const offset = 80
                        const x = Phaser.Math.Clamp(targetX + (Math.random() > 0.5 ? offset : -offset), 100, GameSettings.canvas.width - 100)
                        const y = targetY + (Math.random() > 0.5 ? offset : -offset)

                        const coin = this.coins.create(x, y, 'coin')
                        coin.setDisplaySize(GameSettings.gameplay.obstacleSize, GameSettings.gameplay.obstacleSize)
                        // Hitbox is 2x display size for easier collection
                        const textureSize = GameSettings.gameplay.obstacleSize
                        const hitboxSize = textureSize * 2
                        coin.body.setSize(hitboxSize, hitboxSize)
                        coin.body.setOffset((textureSize - hitboxSize) / 2, (textureSize - hitboxSize) / 2)
                        this.tweens.add({
                            targets: coin,
                            angle: 360,
                            duration: 1200,
                            repeat: -1
                        })
                    }

                    shrinkObject(obj, canShrink = false) {
                        if (!obj || !canShrink) return

                        // Side walls should not shrink
                        if (this.walls.contains(obj)) return

                        // Per-object cooldown to prevent "drilling"
                        const now = this.time.now
                        if (obj.lastShrinkTime && now - obj.lastShrinkTime < 200) {
                            return
                        }
                        obj.lastShrinkTime = now

                        // Initialize hit counter and original scale if they don't exist
                        if (obj.hitCount === undefined) {
                            obj.hitCount = 0
                            obj.originalScale = obj.scaleX
                        }

                        // Increment hit count
                        obj.hitCount++

                        // Calculate new scale: loss of 20% of original size per hit (5 hits to destroy)
                        const newScale = obj.originalScale * (1 - (obj.hitCount * 0.2))

                        if (newScale <= 0.01 || obj.hitCount >= 5) {
                            // Destroy object after 5 hits or when scale reaches 0
                            obj.destroy()
                        } else {
                            // Apply shrinking
                            obj.setScale(newScale)

                            // Update physics body size
                            if (obj.body) {
                                obj.body.updateFromGameObject()
                            }
                        }
                    }

                    handleDeath() {
                        if (this.isGameOver) return
                        this.isGameOver = true

                        this.physics.pause()

                        // Safety check: ensure this.player is a valid sprite before calling setTint
                        if (this.player && typeof this.player.setTint === 'function') {
                            this.player.setTint(0xff0000)
                        }

                        if (this.playerEyes) this.playerEyes.setVisible(false)

                        // Show game over UI only when NOT in Remix
                        if (!this.isInRemix()) {
                            this.showGameOverUI()
                        }

                        this.endGame()
                    }

                    showGameOverUI() {
                        // Semi-transparent overlay
                        this.gameOverOverlay = this.add.rectangle(
                            GameSettings.canvas.width / 2,
                            GameSettings.canvas.height / 2,
                            GameSettings.canvas.width,
                            GameSettings.canvas.height,
                            0x000000, 0.8
                        ).setScrollFactor(0).setDepth(200)

                        // Game Over text (bigger)
                        this.gameOverText = this.add.text(
                            GameSettings.canvas.width / 2,
                            GameSettings.canvas.height / 2 - 120,
                            'GAME OVER',
                            {
                                fontFamily: 'Arial',
                                fontSize: '64px',
                                fontStyle: 'bold',
                                color: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 6
                            }
                        ).setOrigin(0.5).setScrollFactor(0).setDepth(201)

                        // Final score - HUGE number only
                        this.finalScoreText = this.add.text(
                            GameSettings.canvas.width / 2,
                            GameSettings.canvas.height / 2 + 20,
                            '' + this.score,
                            {
                                fontFamily: 'Arial',
                                fontSize: '96px',
                                fontStyle: 'bold',
                                color: '#ffffff',
                                stroke: '#000000',
                                strokeThickness: 4
                            }
                        ).setOrigin(0.5).setScrollFactor(0).setDepth(201)

                        // Restart button (bigger, white with black text)
                        this.restartButton = this.add.rectangle(
                            GameSettings.canvas.width / 2,
                            GameSettings.canvas.height / 2 + 160,
                            280, 70,
                            0xffffff
                        ).setScrollFactor(0).setDepth(201).setInteractive({ useHandCursor: true })

                        this.restartButtonText = this.add.text(
                            GameSettings.canvas.width / 2,
                            GameSettings.canvas.height / 2 + 160,
                            'PLAY AGAIN',
                            {
                                fontFamily: 'Arial',
                                fontSize: '32px',
                                fontStyle: 'bold',
                                color: '#000000'
                            }
                        ).setOrigin(0.5).setScrollFactor(0).setDepth(202)

                        // Handle restart button click
                        this.restartButton.on('pointerdown', () => {
                            this.restartGame()
                        })
                    }

                    update(time, delta) {
                        if (this.isGameOver) return

                        // Continuous input: Check if mouse or finger is down
                        // But ignore input for 300ms after restart to prevent "Play Again" from triggering flap
                        const timeSinceRestart = Date.now() - this.restartTime
                        if (this.input.activePointer.isDown && timeSinceRestart > 300) {
                            this.flap()
                        }

                        // Update Parallax TileSprites with specific scroll factors
                        if (this.bgFar && this.bgMid) {
                            this.bgFar.tilePositionY = this.cameras.main.scrollY * 0.1
                            this.bgMid.tilePositionY = this.cameras.main.scrollY * 0.3
                        }

                        // Position eyes relative to player
                        if (this.player && this.playerEyes) {
                            // Organic Smooth Eye Movement logic
                            // Look towards horizontal velocity
                            const lookVelX = Phaser.Math.Clamp(this.player.body.velocity.x / 20, -6, 6)
                            const lookVelY = Phaser.Math.Clamp(this.player.body.velocity.y / 40, -4, 4)

                            // Random "inquisitive" glancing every now and then
                            if (time % 2000 < 50) {
                                this.targetEyePos.x = lookVelX + (Math.random() - 0.5) * 4
                                this.targetEyePos.y = lookVelY + (Math.random() - 0.5) * 4
                                this.targetPupilPos.x = (Math.random() - 0.5) * 4
                                this.targetPupilPos.y = (Math.random() - 0.5) * 4
                            } else {
                                this.targetEyePos.x = lookVelX
                                this.targetEyePos.y = lookVelY
                                this.targetPupilPos.x = lookVelX * 0.5
                                this.targetPupilPos.y = lookVelY * 0.5
                            }

                            // Smooth lerp for organic eye movement
                            this.currentEyePos.x += (this.targetEyePos.x - this.currentEyePos.x) * 0.15
                            this.currentEyePos.y += (this.targetEyePos.y - this.currentEyePos.y) * 0.15
                            this.currentPupilPos.x += (this.targetPupilPos.x - this.currentPupilPos.x) * 0.15
                            this.currentPupilPos.y += (this.targetPupilPos.y - this.currentPupilPos.y) * 0.15

                            this.eyeLeft.x = -24 + this.currentEyePos.x
                            this.eyeLeft.y = -4 + this.currentEyePos.y
                            this.eyeRight.x = 24 + this.currentEyePos.x
                            this.eyeRight.y = -4 + this.currentEyePos.y

                            this.pupilLeft.x = this.eyeLeft.x + this.currentPupilPos.x
                            this.pupilLeft.y = this.eyeLeft.y + this.currentPupilPos.y
                            this.pupilRight.x = this.eyeRight.x + this.currentPupilPos.x
                            this.pupilRight.y = this.eyeRight.y + this.currentPupilPos.y
                        }

                        if (this.player.body.velocity.y > 800) {
                            this.player.body.setVelocityY(800)
                        }

                        if (this.hasStarted) {
                            // Increment the target position by current speed (speed is now constant within cycles)
                            this.surgeTargetY -= (GameSettings.gameplay.hazardSpeed * delta / 1000)

                            // Smoothly interpolate the actual container towards the target
                            // This ensures high-speed movement without popping or jitter
                            const surgeLerpSpeed = 0.02
                            this.spikeContainer.y += (this.surgeTargetY - this.spikeContainer.y) * surgeLerpSpeed

                            // Undulate individual spikes
                            this.spikes.forEach((s, idx) => {
                                s.y = Math.sin((time / 200) + idx) * 10
                            })

                            this.spikeContainer.body.updateFromGameObject()

                            // Update pentagons: rotation oscillation (movement handled by velocity)
                            this.pentagons.children.each((pentagon) => {
                                if (!pentagon.active) return

                                // Oscillate rotation based on time since spawn
                                const elapsed = time - pentagon.spawnTime
                                pentagon.angle = Math.sin(elapsed * pentagon.rotationSpeed) * pentagon.rotationRange
                            })

                            // Check for interval milestones
                            const currentAltitude = this.getPlayerAltitude()

                            if (this.nextIntervalIndex < this.intervalAltitudes.length &&
                                currentAltitude >= this.intervalAltitudes[this.nextIntervalIndex]) {
                                this.handleIntervalReached(this.intervalAltitudes[this.nextIntervalIndex])
                            }

                            // Spike Warning System - update based on spike distance
                            this.updateSpikeWarning(time)

                            // Update hexagon pairs (firing, spinning, beams)
                            this.updateHexagonPairs(time)

                        }

                        const currentCamTop = this.cameras.main.scrollY
                        if (currentCamTop < this.highestGeneratedY + GameSettings.canvas.height) {
                            this.generateChunk(currentCamTop - GameSettings.canvas.height)
                        }

                        const cleanupLimitY = this.spikeContainer.y + 400
                        this.walls.children.each((wall) => {
                            if (wall.active && wall.y > cleanupLimitY) {
                                wall.destroy()
                            }
                        })
                        this.obstacles.children.each((obs) => {
                            if (obs.active && obs.y > cleanupLimitY) {
                                obs.destroy()
                            }
                        })
                        this.coins.children.each((coin) => {
                            if (coin.active && coin.y > cleanupLimitY) {
                                coin.destroy()
                            }
                        })
                        this.pentagons.children.each((pentagon) => {
                            if (pentagon.active && pentagon.y > cleanupLimitY) {
                                pentagon.destroy()
                            }
                        })
                        // Cleanup hexagons
                        this.hexagons.children.each((hexagon) => {
                            if (hexagon.active && hexagon.y > cleanupLimitY) {
                                hexagon.destroy()
                            }
                        })
                        // Cleanup hexagon beams
                        this.hexagonBeams.children.each((beam) => {
                            if (beam.active && beam.y > cleanupLimitY) {
                                beam.destroy()
                            }
                        })

                        if (this.player.y > this.spikeContainer.y + 50) {
                            this.handleDeath()
                        }
                    }

                    endGame() {
                        console.log('Game Over! Score:', this.score)
                        if (window.FarcadeSDK && window.FarcadeSDK.singlePlayer) {
                            window.FarcadeSDK.singlePlayer.actions.gameOver({ score: this.score })
                        }
                    }

                    onConfigUpdate(path, value, oldValue) {
                        // Handle Color updates dynamically
                        if (path.startsWith('colors.')) {
                            if (path === 'colors.background') {
                                this.cameras.main.setBackgroundColor(value)
                            } else {
                                this.textures.remove('player')
                                this.textures.remove('block')
                                this.textures.remove('spike_single')
                                this.generateTextures()

                                this.player.setTexture('player')
                                this.walls.children.each(c => c.setTexture('block'))
                                this.obstacles.children.each(c => c.setTexture('block'))
                                this.coins.children.each(c => c.setTexture('coin'))
                                this.spikes.forEach(s => s.setTexture('spike_single'))
                                this.scoreText.setColor(GameSettings.colors.primary)
                            }
                        }

                        // Real-time Physics Tweak
                        if (path === 'gameplay.gravity') {
                            this.physics.world.gravity.y = value
                        }

                        // If we change obstacle frequency, we don't need to do anything immediately,
                        // the next generate call will picking it up.
                    }
                }

                /**
                 * Initialize and start the game
                 */
                function initGame() {
                    // Calculate initial dimensions based on available space
                    const container = document.getElementById('game-container');
                    const containerWidth = container.clientWidth || window.innerWidth;
                    const containerHeight = container.clientHeight || window.innerHeight;

                    // Fixed logical width, dynamic height
                    const BASE_WIDTH = 720;
                    const MIN_HEIGHT = 1080; // 2:3 ratio minimum

                    // Calculate scale factor based on width
                    const scaleFactor = containerWidth / BASE_WIDTH;

                    // Calculate how much height we can show at this scale
                    const availableLogicalHeight = containerHeight / scaleFactor;

                    // Use the larger of MIN_HEIGHT or available height
                    const gameHeight = Math.max(MIN_HEIGHT, Math.floor(availableLogicalHeight));

                    // Update GameSettings with calculated height
                    GameSettings.canvas.height = gameHeight;

                    const config = {
                        type: Phaser.WEBGL,
                        parent: 'game-container',
                        width: BASE_WIDTH,
                        height: gameHeight,
                        scale: {
                            mode: Phaser.Scale.FIT,
                            autoCenter: Phaser.Scale.CENTER_BOTH,
                            width: BASE_WIDTH,
                            height: gameHeight,
                        },
                        backgroundColor: GameSettings.colors.background,
                        scene: [GameScene],
                        physics: {
                            default: 'arcade',
                            arcade: {
                                debug: false,
                                steps: 8,
                                tileBias: 64,
                                overlapBias: 16,
                                fps: 60
                            }
                        },
                        fps: {
                            target: 60,
                            forceSetTimeOut: false,
                            panicMaxBlocks: 10
                        },
                        pixelArt: false,
                        antialias: true,
                        roundPixels: false,
                    }

                    try {
                        const game = new Phaser.Game(config)
                        console.log('[GAME] Phaser game initialized successfully')

                        game.events.once('ready', () => {
                            const scene = game.scene.getScene('GameScene')
                            if (scene) {
                                ConfigManager.init(game, scene)
                            }
                        })

                        setTimeout(() => {
                            if (!ConfigManager.gameInstance) {
                                const scene = game.scene.getScene('GameScene')
                                if (scene) {
                                    ConfigManager.init(game, scene)
                                }
                            }
                        }, 100)
                    } catch (error) {
                        console.error('[GAME] Failed to create Phaser.Game:', error)
                    }
                }

                initGame()
                // === END FILE: main.js ===

                console.log('[Run Game] Game code executed successfully');
            } catch (error) {
                console.error('[Run Game] Error executing game code:', error);
                console.error('[Run Game] Stack trace:', error.stack);
                throw error;
            }
        })().catch(error => {
            console.error('[Run Game] Unhandled error in game initialization:', error);
        });
    </script>
</body>

</html>